# 约数、同余学习总结

#### PS: 这次题竟然变水了，竟然第一次是第三个 AK 的

约数，就是因数，比如 $10$ 的约数就有 $1$, $2$, $5$, $10$ 这四个。

求法：

$O(\sqrt{n})$ 但是要特判完全平方数。

```cpp
bool check(int x) {
    for (int i = 2; i * i <= x; i++) if (n % i == 0) printf("%d %d\n", i, n / i);
}
```

而同余，就是比如 $a$ % $m$ $=$ $x$ 且 $b$ % $m$ $=$ $x$  则称 $a$ 和 $b$ 在模 $m$ 的意义下同余。

质数，就是只有两个约数的数就叫质数。

求法：

$O(\sqrt{n})$

```cpp
bool check(int x) {
    for (int i = 2; i * i <= x; i++) if (x % i == 0) return false;
    return true;
}
```

但是这样多组查询就效率不够高了。

所以可以预处理。

$O(n\log \log {n})$

或

$O(n\log n)$

```cpp
for (int i = 2; i * i <= n; i++) if (!pre[i]) for (int j = i * i; j <= n; j += i) pre[j] = true;
```

最大公约数就是可以理解为这样：

给你两个整数 $a, b$

有一个集合 $S$

从 $S$ 中任取一数 $x$，$x$ 满足 $a$ % $x$ $=$ $0$ 且 $b$ % $x$ $=$ $0$

将 $S$ 从小到大排序，此时 $S$ 末尾的元素就是 $\gcd(a, b)$

$\gcd$ 一般使用辗转相除法实现

```cpp
int gcd(int a, int b) {return (b == 0 ? a : gcd(b, a % b));}
```

逆元，就可以理解为倒数，一般有两种方法：

$O(n\log{m})$

和

$O(n)$

$o(n\log{m})$ ~~我不会~~

$O(n)$ 实现方法：

```cpp
inv[1] = 1;
rep(i, 2, n) {inv[i] = (mod - mod / i) * inv[mod % i] % mod;}
```



## 例题：

### T1: [最大公约数](https://vjudge.net/contest/752063#problem)

开胃小菜。

就是用辗转相除法求 $\gcd$

上面已经讲过了，直接上代码

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = 1LL << 60LL;
const int mod = 998244353;

using namespace std;

const int N = 2e5 + 10; 
int x, y, z;

int gcd(int a, int b) {return (b == 0 ? a : gcd(b, a % b));}

int main() {
    scanf("%d%d%d", &x, &y, &z);
    printf("%d\n", gcd(x, gcd(y, z)));
}
```

### T2: [素数个数](https://vjudge.net/contest/752063#problem/F)

题目说 $n \leqslant {10^8}$ 但实际可以用埃氏筛卡过。

实现上面也说了，直接上代码

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = 1LL << 60LL;
int mod = 998244353;

using namespace std;

const int N = 1e8 + 10;
int n, ans;
bool b[N];

bool check(int x) {
    for (int i = 2; i * i <= x; i++) if (x % i == 0) return false;
    return true;
}

int main() {
    scanf("%d", &n);
    for (int i = 2; i * i <= n; i++) if (!b[i]) for (int j = i * i; j <= n; j += i) b[j] = true;
    rep(i, 2, n) ans += !b[i];
    printf("%d\n", ans);
}
```

### T3 : [模意义下的乘法逆元](https://vjudge.net/contest/752063#problem/K)

其实就是逆元，之前也讲过了，直接上代码

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = 1LL << 60LL;
int mod = 998244353;

using namespace std;

const int N = 3e6 + 10; 
int n, p;
ll inv[N];

int main() {
    scanf("%d%d", &n, &p);
	mod = p;
	inv[1] = 1;
    printf("%lld\n", inv[1]);
	rep(i, 2, n) {
		inv[i] = (mod - mod / i) * inv[mod % i] % mod;
        printf("%lld\n", inv[i]);
	}
}
```

### 附加：[Coprime](https://vjudge.net/problem/CodeForces-1742D)

CF的题，之前连1100都做了，~~现在连800都做不出来了~~。

首先我们发现 $n$ 的范围很大，但是数组的范围很小，所以可以考虑从遍历每个元素的位置变成遍历每个元素。

然后就是简单模拟了。

## 代码：

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = 1LL << 60LL;
const int mod = 998244353;

using namespace std;

const int N = 2e5 + 10;
int t, n, ans, a[N], pos[2010];

void solve() {
    scanf("%d", &n);
    rep(i, 1, n) {
        int x;
        scanf("%d", &x);
        pos[x] = i;
    }
    ans = 0;
    rep(i, 1, 1000) rep(j, 1, 1000) if (__gcd(i, j) == 1 && pos[i] != 0 && pos[j] != 0) 
        ans = max(ans, pos[i] + pos[j]);
    printf("%d\n", ans);
}

int main() {
    scanf("%d", &t);
    while (t--) solve();
}

```

