# 10.6 雅礼总结

### 分数：90 + 90 + 70 = 250 分，如你所见，没有一道满分。

PS: bushi:(，雅礼教师机是什么老爷机，nm我在yl503上面75ms的代码在教师机上面硬生生给我跑超时。

再PS: 没错我这次吸取了上次的惨痛教训，没有把freopen打错，但是tm把freopen给注释了，nm夺走我30分。

## T1

 诈骗 + 一点点的数学。

先将 $a$ 排序，然后再去求每一种题目。

题目一就是将最小的数减去其他的数，最大的数不要减，最后输出最小的数就好了。

题目二直接保留最小的数肯定是最优的。

要特判 $n = 1$

$O(n\log{n})$

### 代码

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 62LL) - 1;
const int mod = 998244353;

using namespace std;

const int N = 100010;
int n, k;
ll a[N];

int main() {
    scanf("%d%d", &n, &k);
    rep(i, 1, n) scanf("%lld", &a[i]);
    sort(a + 1, a + n + 1);
    if (n == 1) return printf("%lld\n", a[1]), 0;
    if (k == 1) {
        rep(i, 2, n - 1) a[1] -= a[i];
        printf("%lld\n", a[n] - a[1]);
    } else printf("%lld\n", a[1]);
}
```

## T2

大%你。

其实我就是按情况分类讨论。

#### 情况一：本来就是回文串

最简单的一种，就是找的第一个不为 $a$ 的位置 $pos$，然后把 $a[pos] = a[n - pos + 1] = 'a'$ 就行了

#### 情况二：只有一个地方不回文

最复杂的一种，因为只有一个地方不回文，需要修改，所以还需要分情况讨论。
如果说这个位置两边没有一个为 $a$ 或者 $n$ 为偶数，那么只需要把当前位置左右两边设为 $a$ 就行了。

否则就把左右两边都设为 $a$ 然后再把中间位置设为 $a$ 就行了。

#### 情况三：有两个地方不回文

就只需要把这两个位置的左右两边设为较小的就行了。

$O(n)$

### 代码

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 62LL) - 1;
const int mod = 998244353;

using namespace std;

const int N = 1e3 + 10;
string s;
bool ok = true;
queue<int> q;
int n;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    cin >> s;
    n = s.size();
    s = " " + s;
    if (n == 1) return puts("a"), 0;
    rep(i, 1, n >> 1) if (s[i] != s[n - i + 1]) ok = false, q.push(i);
    if (ok) {
        rep(i, 1, n >> 1) if (s[i] != 'a') {
            s[i] = s[n - i + 1] = 'a';
            break;
        }
        rep(i, 1, n) cout << s[i];
        cout << '\n';
        return 0;
    }
    if (q.size() == 1) {
        int pos = q.front();
        q.pop();
        if ((s[pos] != 'a' && s[n - pos + 1] != 'a') || !(n & 1)) s[pos] = s[n - pos + 1] = 'a';
        else s[pos] = s[n - pos + 1] = 'a', s[(n >> 1) + 1] = 'a';
    } else {
        int pos = q.front();
        q.pop();
        if (s[pos] <= s[n - pos + 1]) s[n - pos + 1] = s[pos];
        else s[pos] = s[n - pos + 1];
        pos = q.front();
        q.pop();
        if (s[pos] <= s[n - pos + 1]) s[n - pos + 1] = s[pos];
        else s[pos] = s[n - pos + 1];
    }
    rep(i, 1, n) cout << s[i];
    cout << '\n';
}
```

## T3

被雅礼老爷教师机卡常了。

赛时不知道为什么觉得如果相加为质数就 $ans$++ 是错的。

提供一种类似贪心的做法。

先筛出 $1$ 至 $2e6$ 的质数

如果这条边两端相加为质数的话就说明可以染 $u$ 也可以染 $v$ 所以就说明 $u, v$ 这条边上又多了一种选择，让 $cnt[u]++, cnt[v]++$。

再把这条边存下来。

接着，统计完了每个点有多少种选择后再枚举这些边。

如果这条边两端的点都被染了，就说明不用看了，直接枚举下一条边。

否则就染剩余选择小的那个点，将它染色，再将它的选择设为 $\inf$

最后再将 $cnt[u]$ --，$cnt[v]$ --。

$O(n)$

### 代码：

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 62LL) - 1;
const int mod = 998244353;

using namespace std;

const int N = 3e5 + 10;
struct node {
    int u, v;
};
int n, ans, a[N], cnt[N];
bool pre[N * 10];
vector<node> g;

int main() {
    scanf("%d", &n);
    for (int i = 2; i * i <= 2e6; i++) if (!pre[i])
        for (int j = i * i; j <= 2e6; j += i) pre[j] = true; 
    rep(i, 1, n) scanf("%d", &a[i]);
    rep(i, 1, n - 1) {
        int u, v;
        scanf("%d%d", &u, &v);
        if (!pre[a[u] + a[v]]) cnt[u]++, cnt[v]++, g.pb({u, v});
    }
    for (auto y : g) {
        int u = y.u, v = y.v;
        if (cnt[u] == inf && cnt[v] == inf) continue;
        else if (cnt[u] <= cnt[v]) ans++, cnt[u] = inf;
        else if (cnt[v] != inf) ans++, cnt[v] = inf;
        if (cnt[u] != inf) cnt[u]--;
        if (cnt[v] != inf) cnt[v]--;
    }
    printf("%d\n", ans);
}
```

## T4

数学。

思路就和oymz差不多也是把 $[1, 5e6]$ 分成了五个区间，然后求每个区间的值。

但是被rmx给hack了。

主要就是 $c[i]$ 不只是 $[1, 5]$

然后经过计算，因该开到10以上就行了。

### 代码:

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 62LL) - 1;
const int mod = 998244353;

using namespace std;

const int N = 1e5 + 10, mxb = 1e6;
int n, ans, a[N];

int main() {
    scanf("%d", &n);
    rep(i, 1, n) scanf("%d", &a[i]);
    auto calc = [&](int x) {
        int res = 0;
        rep(i, 1, n) res += (a[i] >= x && a[i] < (x + 1) * mxb && a[i] / (a[i] / x) == x);
        return res;
    };
    rep(i, 1, 15) ans = max(ans, calc(i));
    printf("%d\n", ans);
}
```

