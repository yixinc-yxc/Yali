## 二分定义
二分查找（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是用来在一个有序数组中查找某一元素的算法。
                                         ——OI-wiki
# 二分查找
二分法可以大大优化时间复杂度，简单来说就是每次判断这个区间的中间数是否可行，然后把这个区间折半，一共会折 $\log(n)$ 次，（这里 $log$ 指一个数最多能除几次二）。
## 四种方法：
- 左闭右闭区间
- 左闭右开区间
- 左开右闭区间（玩命）
- 左开右开区间

## [见此题目](https://www.luogu.com.cn/problem/P2249)

## 歪解
第一眼一看，哎，一个暴力解决，时间复杂度 $O(nm)$

结果。。。 $n <= 10^6, m <= 10^5$ 能过我吃。

代码就不放了，相信大家都会 ~~不会是**~~
## 正解
先读入 $a$ 数组，然后读入每个询问，每次询问都二分查找一下，就完了。

**AC code**
```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m, a[1000010]; 

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	while (m--) {
		int x;
		scanf("%d", &x);
		int it = lower_bound(a + 1, a + n + 1, x) - a;
		if (a[it] != x) printf("-1 "); 
		else printf("%d ", it);
	}
} 
```


------------

# 二分答案
二分最主要的就是check，其它的地方差不多都是一样的。

——PTY

没错，二分的确是check最重要。

二分有两种题，一种是送分题，另一种是送命题。

——dlsh（杜瑜皓）

送分题可以看这两道： [1](https://www.luogu.com.cn/problem/P2249)
 [2](https://www.luogu.com.cn/problem/P8647)

送命题可以看这两道:  [1](https://www.luogu.com.cn/problem/P2619)
 [2](https://www.luogu.com.cn/problem/P3534)

 ## 例题
[题面](https://www.luogu.com.cn/problem/P1314)

这道题就是二分+前缀和
**代码**
```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = 1LL << 60LL;
const int mod = 1e9;

const int N = 2e5 + 10;
int n, m, w[N], v[N], l[N], r[N];
ll s, c[N], d[N];

inline ll calc(int W) {
	if (W == -1) return INF;
	if (W == 1000002) return -INF;
	rep(i, 1, n) c[i] = (w[i] >= W), d[i] = (w[i] >= W) ? v[i] : 0;
	rep(i, 1, n) c[i] += c[i - 1], d[i] += d[i - 1];
	ll sum = 0;
	rep(i, 1, m) {
		sum += (c[r[i]] - c[l[i] - 1]) * (d[r[i]] - d[l[i] - 1]);
		sum = min(sum, INF);
	}
	return sum;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	scanf("%d%d%lld", &n, &m, &s);
	rep(i, 1, n) scanf("%d%d", &w[i], &v[i]);
	rep(i, 1, m) scanf("%d%d", &l[i], &r[i]);
	int L = -1, R = 1000002;
	while (L + 1 < R) {
		int mid = L + (R - L) / 2;
		if (calc(mid) >= s) L = mid;
		else R = mid;
	}
	printf("%lld\n", min(abs(calc(L) - s), abs(s - calc(R))));
}
```
# 附加：STL
lower_bound(a + 1, a + n + 1, p)，表示在长度为 $n$ 的 $a$ 数组里查找第一个大于等于 $p$ 的数的位置。

upper_bound(a + 1, a + n + 1, p)，表示在长度为 $n$ 的 $a$ 数组里查找第一个大于 $p$ 的数的位置。

详见OI-wiki
# 总结

二分是一个好用的算法，它不仅可以查找元素，还可以有其他变种（比如：二分答案），有的时候也可以用STL去~~偷懒~~应付，但要注意STL的常数！


