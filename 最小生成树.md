# 最小生成树

### 定义

从一张 $n$ 个点 $m$ 条边的连通图中取出一棵树，使得这棵树包含$n - 1$ 条边，并且包含 $n$ 个点，这棵树便是这个图的生成树，而边权和最小的生成树就是最小生成树。 

#### **注意：不连通的图只有最小生成森林！！！ 所以要特判**

看到这里，可能你会觉得最小生成树就是把边权最小的几条边的边权给加起来就好了，但是这样是错的，你无法保证这几条边组起来是生成树，这是我们就需要其它算法。

### 算法一 ：kruskal

$kruskal$ 大概流程就是先把 $m$ 条边存下来，然后在从小到大排序，然后再枚举这 $m$ 条边每次把这条边能加就加入最小生成树中，每次要用并查集判一下这条边的两端是否已经加过了。

#### 代码

```cpp
void kruskal() {
	for (auto [u, v, w] : g) if (gf(u) != gf(v)) {
		f[gf(u)] = gf(v);//并查集合并
		ans += w;
		cnt++;//生成树边数加一
        if (cnt == n - 1) continue;
	}
}
```

很明显，从代码可以看出，这个算法是以边作为中心。

**时间复杂度：$O(mlogm + m *\alpha(m, n))$**

**空间复杂度：$O(m + n)$**

### 算法二 ： prim

$prim$ 算法也是一种求最小生成树的算法，与 $kruskal$ 不同的是，$kruskal$ 是以边作为中心，而 $Prim$ 是以点作为中心，和 $dijkstra$ 相似，prim是每次将新的点加入生成树，也是贪心的想法，找到边权最小并且未加入生成树的点，加入生成树。

#### 代码

```cpp
void Prim() {
	fill(dis, dis + n + 1, inf);//不知道有啥用，但是每次编Prim总是有这个东西
	dis[1] = 0;
	q.push({1, 0});//小根堆
	while (!q.empty()) {
		if (cnt >= n) break;
		int u = q.top().u, d = q.top().d;
		q.pop();
		if (vis[u]) continue;//如果已经到了生成树里面就不用访问了
		vis[u] = true;
		++cnt;//生成树点数加一
		ans += d;
		for (auto [v, w] : g[u]) if (w < dis[v]) dis[v] = w, q.push({v, w});
	}
}
```

**时间复杂度：$O((n + m)logn)$**

**空间复杂度：涉及STL，就不算了**

## 例题

### 例题一：最小生成树

**题意：**

给你一个图，让你求出这个图的最小生成树，不连通输orz。

**思路：**

这道题就是一道最小生成树模板题，思路上面讲了，直接放代码

**代码**

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 62LL) - 1;
const int mod = 998244353;

using namespace std;

const int N = 2e5 + 10;
struct node {
	int u, v, w;
	bool operator < (const node &A) const {
		return w < A.w;
	}
}g[N];
int n, m, ans, f[N];

void init() {
	rep(i, 1, n) f[i] = i;
}

int gf(int x) {
	return f[x] == x ? x : f[x] = gf(f[x]);
}

void kruskal() {//kruskal算法
	rep(i, 1, m) if (gf(g[i].u) != gf(g[i].v)) {
		f[gf(g[i].u)] = gf(g[i].v);
		ans += g[i].w;
		n--;
	}
}

int main() {
	scanf("%d%d", &n, &m);
	init();
	rep(i, 1, m) scanf("%d%d%d", &g[i].u, &g[i].v, &g[i].w);
	sort(g + 1, g + m + 1);
	kruskal();
	if (n == 1) printf("%d\n", ans);
	else puts("orz");
}
```

### 例题二：Bad Cowtractors S

**题意：**

给你一个图，让你求出这个图的最大生成树，求不出输-1。

**思路：**

第一眼看过去，咦？最大生成树好像没有学过，这时，让我们想一想，最小生成树是按边权从小到大排序，那最大生成树不就是将边权从大到小排吗？这样题目就解决了。

**代码**

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 62LL) - 1;
const int mod = 998244353;

using namespace std;

const int N = 2e5 + 10;
struct node {
	int u, v, w;
	bool operator < (const node &A) const {
		return w < A.w;
	}
};
int n, m, ans, f[N];
vector<node> g;

void init() {
	rep(i, 1, n) f[i] = i;
}

int gf(int x) {
	return f[x] == x ? x : f[x] = gf(f[x]);
}

void kruskal() {
	for (auto [u, v, w] : g) if (gf(u) != gf(v)) {
		f[gf(u)] = gf(v);
		ans += w;
		n--;
	}
}

int main() {
	scanf("%d%d", &n, &m);
	init();
	rep(i, 1, m){
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		g.pb({u, v, w});
	}
	sort(all(g));
	reverse(all(g));
	kruskal();
	if (n == 1) printf("%d\n", ans);
	else puts("-1");
}
```

### 例题三：繁忙的都市

阅读理解。

**题意：**

给你一个图，让你求出最小生成树有几条边和最小生成树中最大的边权。

**思路：**

类似板子，就只不过是需要多求一个最大边权。

**代码**

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 62LL) - 1;
const int mod = 998244353;

using namespace std;

const int N = 310;
struct node {
	int u, v, w;
	bool operator < (const node &A) const {
		return w < A.w;
	}
};
vector<node> g;
int n, m, ans1, ans2, f[N];

void init() {
	rep(i, 1, n) f[i] = i;
}

int gf(int x) {
	return f[x] == x ? x : f[x] = gf(f[x]);
}

void kruskal() {
	for (auto [u, v, w] : g) if (gf(u) != gf(v)) {
		f[gf(u)] = gf(v);
		ans1++;
		ans2 = max(ans2, w);
	}
}

int main() {
	scanf("%d%d", &n, &m);
	init();
	rep(i, 1, m) {
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		g.pb({u, v, w});
	}
	sort(all(g));
	kruskal();
	printf("%d %d\n", ans1, ans2);
}
```

### 例题四：Cheering up the Cow G

**题意：**

给你一个图，你需删一些边，得到图G，每次经过图G的一个点，sum都会加上点权，经过边时也会加上边权，要从图上任意一个点走一圈走回来，求sum最小为多少。

**思路：**

首先，我们发现它需要把边权和算进去，可见走了边权很大的边是肯定不优的，所以我们可以把边权较大的边删掉，然后我们又发现：还要保证删过边之后的图还要联通，所以我们可以想到最小生成树。

但是这里又有一个点权，这时，我们就可以改边权，只需要把边先*2，然后全都加上两端点的点权，就好了，边权乘2是因为我们还要走回来，每条边要经过两次，所以乘2。

还有一个问题，起点应该选那个点呢，因为点权要算两次，所以我们只要找到点权最小的那个点作为起点就好了。

**代码**

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 62LL) - 1;
const int mod = 998244353;

using namespace std;

const int N = 100010;
struct node {
	int u, v, w;
	bool operator < (const node &A) const {
		return w < A.w;
	}
};
vector<node> g;
int n, m, cnt, mi = inf, ans, a[N], f[N];

void init() {
	rep(i, 1, n) f[i] = i;
}

int gf(int x) {
	return f[x] == x ? x : f[x] = gf(f[x]);
}

void kruskal() {
	for (auto [u, v, w] : g) if (gf(u) != gf(v)) {
		f[gf(u)] = gf(v);
		cnt++;
		ans += w;
		if (cnt == n - 1) break;
	}
}

int main() {
	scanf("%d%d", &n, &m);
	init();
	rep(i, 1, n) scanf("%d", &a[i]), mi = min(mi, a[i]);
	rep(i, 1, m) {
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		g.pb({u, v, w});
		g[i - 1].w = g[i - 1].w * 2 + a[g[i - 1].u] + a[g[i - 1].v];
	}
	sort(all(g));
	kruskal();
	printf("%d\n", ans + mi);
}
```

### 后记：

其实还有一种求最小生成树的算法：boruvka，但我不会，就不讲了。
