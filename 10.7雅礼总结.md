# 10.7雅礼总结

## 总分： 100 + 20 + 70 + 15 = 205

这次没有意外，纯粹就是做法错了。

## T1

easy。

暴力枚举一下，只要会循环和取模就能做。

$O((r - l + 1)n)$

### 代码：

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 62LL) - 1;
const int mod = 998244353;

using namespace std;

const int N = 3010;
int n, l, r, ans, a[N];
ll res = INF;

int main() {
    scanf("%d%d%d", &n, &l, &r);
    rep(i, 1, n) scanf("%d", &a[i]);
    rep(k, l, r) {
        ll sum = 0;
        rep(i, 1, n) sum += a[i] % k;
        if (sum < res) {
            res = sum;
            ans = k;
        }
    }
    printf("%d\n", ans);
}
```

## T2

有点意思。

赛时挂了80。

其实有一种很简单的方法。

```cpp
scanf("%d", &t);
auto solve = [&]() {
    scanf("%lld%d", &a, &k);
    printf("%lld\n", (ll)pow(10, k) / __gcd((ll)pow(10, k), a));
};
while (t--) solve();
```

下面解释一下意思。

首先 $a, k$ 是读进来的，而 $pow(10, k)$ 表示 $10^k$ 而将 $a, 10^k$ 取 $\gcd$ 其实就是把 $a$ 中的 $2, 5$ 给提出来。

我们现在已经知道了 $a$ 有几个零，然后就用 $10^k$ 去除 $10^{a的0的个数}$ 就可以得到最小的 $b$。

为什么是最小的？因为 $10^k$ 一定是最小的有 $k$ 个零的数，所以这样产生的 $b$ 一定是最小的。

$O(\log{k})$

### 代码

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 62LL) - 1;
const int mod = 998244353;

using namespace std;

const int N = 310;
int t, k;
ll a;

int main() {
    scanf("%d", &t);
    auto solve = [&]() {
        scanf("%lld%d", &a, &k);
        printf("%lld\n", (ll)pow(10, k) / __gcd((ll)pow(10, k), a));
    };
    while (t--) solve();
}
```

### T3

暂未做出。

### T4

暂未做出。