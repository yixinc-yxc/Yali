# 莫队学习总结

~~莫队时间复杂度不是很会分析啊，后面再补吧。~~

**contest: [20260105 - 莫队 - Virtual Judge](https://vjudge.net/contest/779399#problem/D) **

## 前置知识：分块

暂时不会。

## 知识点

莫队是一种优雅的暴力，其实看起来和暴力差不多，但是不知道为什么取这个名字。

可以解决一些线段树这样的数据结构不好解决的区间查询问题，但是是一种离线数据结构，而且时间复杂度略大。

比线段树要好写。

当你知道一个区间的答案时，莫队一般可以用 $O(k)$ 的时间复杂度求出相邻区间的答案，但是 $k$ 取值有时不一样具体问题具体分析。 

而莫队，就是看每一次的询问与上一次的询问的左右端点位置的关系，根据关系扩大或缩小，同时统计答案。

乍一看，好像跟暴力没区别，但是再用莫队时我们会先将询问排序，再处理，此时，时间复杂度就变为了 $O(kn\sqrt{n})$

而询问排序是基于分块的一个优化，询问左端点按照块来排，而同块内的按询问右端点来排。

```cpp
std::sort(all(querys), [&](const node &a, const node &b) {
    return (a.l / len != b.l / len ? a.l < b.l : ((a.l / len) & 1) ? a.r < b.r : a.r > b.r);
});
```

注意这里有一个蝶形优化，按照块的奇偶来判断从小往大还是从大往小，可以大大减少扩大或缩小的次数，从而减少时间复杂度。

## 实现

```cpp
void add(int pos) {
    //do sth.
}

void del(int pos) {
    //do sth.
}

void query(const node &q) {
    //扩大操作
    while (l > q.l) add(--l);
    while (r < q.r) add(++r);
    //缩小操作
    while (l < q.l) del(l++);
    while (r > q.r) del(r--);
    ans[q.id] = 本次询问答案
}
```

## 例题

### 莫队 / 小B的询问

模板题。

扩大时先减去数字出现次数的平方，然后次数加一，然后加上次数平方。

缩小时先减去数字出现次数的平方，然后次数减一，然后加上次数平方。

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 998244353;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 1e5 + 10, len = 4e3;
struct node {
    int l, r, id;
};
int n, m, l, r, k, a[N], cnt[N];
ll sum, ans[N];
std::vector<node> querys;

void add(int pos) {
    if (!pos) return;
    sum -= 1ll * cnt[a[pos]] * cnt[a[pos]];
    cnt[a[pos]]++;
    sum += 1ll * cnt[a[pos]] * cnt[a[pos]];
}

void del(int pos) {
    if (!pos) return;
    sum -= 1ll * cnt[a[pos]] * cnt[a[pos]];
    cnt[a[pos]]--;
    sum += 1ll * cnt[a[pos]] * cnt[a[pos]];
}

void query(const node &q) {
    while (l > q.l) add(--l);
    while (r < q.r) add(++r);
    while (l < q.l) del(l++);
    while (r > q.r) del(r--);
    ans[q.id] = sum;
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n >> m >> k;
    rep(i, 1, n) std::cin >> a[i];
    rep(i, 1, m) {
        int l, r;
        std::cin >> l >> r;
        querys.pb({l, r, i});
    }
    std::sort(all(querys), [&](const node &a, const node &b) {
        return (a.l / len != b.l / len ? a.l < b.l : (a.l / len & 1) ? a.r < b.r : a.r > b.r);
    });
    rep(i, 0, m - 1) query(querys[i]);
    rep(i, 1, m) std::cout << ans[i] << '\n';
}

```

### 选数异或

其实只需要注意到这一个性质： $a \oplus b = c$ 则 $c \oplus a = b$ 这题就能做了。

每次扩大是统计一下 $x \oplus 当前数$ 出现了多少次，然后将当前数的出现次数加一。

每次缩小先将出现次数减一，然后减去 $x \oplus 当前数$ 。

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 998244353;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 2e6 + 10, len = 4e3;
struct node {
    int l, r, id;
};
int n, m, l, r, x, a[N], cnt[N];
ll sum;
bool ans[N];
std::vector<node> querys;

void calc(int pos, int op) {
    if (!pos) return;
    if (cnt[x ^ a[pos]] && op == 1) sum += cnt[x ^ a[pos]];
    else sum -= cnt[x ^ a[pos]];
    cnt[a[pos]] += op;
}

void query(const node &q) {
    while (l > q.l) calc(--l, 1);
    while (r < q.r) calc(++r, 1);
    while (l < q.l) calc(l++, -1);
    while (r > q.r) calc(r--, -1);
    ans[q.id] = (sum > 0);
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n >> m >> x;
    rep(i, 1, n) std::cin >> a[i];
    rep(i, 1, m) {
        int l, r;
        std::cin >> l >> r;
        querys.pb({l, r, i});
    }
    std::sort(all(querys), [&](const node &a, const node &b) {
        return  (a.l / len != b.l / len ? a.l < b.l : (a.l / len & 1) ? a.r < b.r : a.r > b.r);
    });
    rep(i, 0, m - 1) query(querys[i]);
    rep(i, 1, m) std::cout << (ans[i] ? "yes" : "no") << '\n';
}

```

如果加上前缀异或和，就能处理区间异或和问题了。