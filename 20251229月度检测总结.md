# 20251229月度检测总结

**contest：[20251229 - 月度检测 - Virtual Judge](https://vjudge.net/contest/778183#problem/C)**

这次除了CF的题目其它全部感觉挺水的，最主要是全是图论，我个人感觉挺擅长图论的，所以这次月度检测竟然取得第一。

选一些题目讲。

按照我做题的顺序讲。

## F：[F - Beautiful Permutation](https://vjudge.net/problem/CodeForces-2162D)

交互式问题，有人赛时因为这个被卡了，结果发现自己会算法，但是不会交互。

首先看到这个找到被修改的区域就能想到可以用二分来解决。

具体就是找到二分的左端点，然后再加上总共修改的值就行了。

详见我之前的代码的注释。

 ```cpp
 #include <bits/stdc++.h>
 
 using ll = long long;
 using ull = unsigned long long;
 using i128 = __int128;
 using db = double;
 #define rep(i, a, b) for (int i = a; i <= b; ++i)
 #define frep(i, b, a) for (int i = b; i >= a; i--)
 #define all(x) (x).begin(), (x).end()
 #define pb push_back
 #define mp make_pair
 #define s second
 #define f first
 const int inf = (1 << 30) - 1;
 const ll INF = (1LL << 62LL) - 1;
 const int mod = 998244353;
 
 using namespace std;
 
 const int N = 2e4 + 10;
 int t, n, p[N];
 
 void solve() {
     //fflush(stdout)
     cin >> n;
     //询问函数 
     auto query = [&](int type, int l, int r) {
         cout << type << ' ' << l << ' ' << r << '\n';
         fflush(stdout);
         int res;
         cin >> res;
         return res;
     };
     
     //求出修改的长度 
     int sum = query(2, 1, n);
     sum -= (n * (n + 1) >> 1);//求出排列P的总和，sum减总和即为修改的长度
     
     // 二分左端点 
     int l = 0, r = n + 1;
     while (l + 1 < r) {
         int mid = l + r >> 1;
         // printf("l, r : %d %d\n", l, r);
         int res1 = query(1, 1, mid), res2 = query(2, 1, mid);
         //求出从 1 到 mid 的两种询问，如果 res1 < res2 则说明从 1 到 mid 中间被修改过
         if (res1 < res2) r = mid;//缩小左端点 
         else l = mid;
     }
     cout << "! " << l + 1 << ' ' << l + sum << '\n';//左闭右闭区间，所以都加一
     fflush(stdout);
 }
 
 int main() {
     scanf("%d", &t);
     while (t--) solve();
 }
 ```

**时间复杂度 ：** $O(2\log{n})$

A就不讲了。

## B：[Maximum Cost Permutation](https://vjudge.net/problem/CodeForces-2144B)

首先其实这道题没我想象的那么难，一开始被难再了怎么填0的位置，后面发现不用，只需要用双指针判断两边是否有序，即 $p_i$ 是否等于 $i$， 如果有序则缩小范围，否则答案即为 $\max(0, r - l + 1)$ 注意只有一个零时要特判。

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 2e9;
const ll INF = 1LL << 60LL;
const int mod = 1e9 + 7;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 2e5 + 10;
int t, n, p[N];
std::vector<int> pos;
bool vis[N];

void solve() {
    std::cin >> n;
    std::fill(vis, vis + n + 1, false), pos.clear();
    rep(i, 1, n) {
        std::cin >> p[i];
        if (!p[i]) pos.pb(i);
        else vis[p[i]] = true;
    }
    if (pos.size() == 1) rep(i, 1, n) if (!vis[i]) p[pos[0]] = i;
    int l = 1, r = n;
    while (l <= n && p[l] == l) l++;
    while (r >= 1 && p[r] == r) r--;
    std::cout << std::max(0, r - l + 1) << "\n";
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> t;
    while (t--) solve();
}
```

**时间复杂度：** $O(n)$

## G：[Laserphones S](https://vjudge.net/problem/洛谷-P2937)

其实一点也不难，我写完一遍就过了。

首先遇到这种问题我已经有过很多次了，基本上就是记录一个来时的方向，看走时的方向是否与来时的方向是否相同，如果相同，则边权为零，否则为一，此时看起来像 01bfs，但是实际上是跑了一个分层图，所以用 `queue` 就行。

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 1e9 + 7;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 110;
const int dx[4] = {-1, 1, 0, 0};
const int dy[4] = {0, 0, -1, 1};
int n, m, sx = -1, sy, tx = -1, ty, dis[4][N][N];
bool vis[4][N][N];
std::string s[N];
std::queue<std::tuple<int, int, int>> q;

void bfs(int sx, int sy) {
    rep(i, 0, 3) rep(j, 1, n) std::fill(dis[i][j] + 1, dis[i][j] + m + 1, inf);
    rep(i, 0, 3) dis[i][sx][sy] = 0;
    rep(i, 0, 3) q.push({i, sx, sy});
    while (!q.empty()) {
        auto &[v, x, y] = q.front();
        q.pop();
        rep(i, 0, 3) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx < 1 || nx > n || ny < 1 || ny > m || s[nx][ny] == '*') continue;
            if (dis[v][x][y] + (v == i ? 0 : 1) < dis[i][nx][ny]) {
                dis[i][nx][ny] = dis[v][x][y] + (v == i ? 0 : 1), q.push({i, nx, ny});
            }
        }
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> m >> n;
    rep(i, 1, n) std::cin >> s[i], s[i] = ' ' + s[i];
    rep(i, 1, n) rep(j, 1, m) {
        if (s[i][j] == 'C' && sx == -1) sx = i, sy = j;
        else if (s[i][j] == 'C') tx = i, ty = j;
    }
    bfs(sx, sy);
    std::cout << std::min({dis[0][tx][ty], dis[1][tx][ty], dis[2][tx][ty], dis[3][tx][ty]});
}
```

**时间复杂度：** $O(4hw)$

其实这种题在我往常做题的时候也遇到过很多了，所以有的时候多刷题是好事。

## H：[受欢迎的牛 G](https://vjudge.net/problem/洛谷-P2341)

对于这种 A 和 B 之间有某种关系且可以传递，其实我觉得你如果图论题刷的多应该对这种描述有一种图论直觉，可以先将这些关系抽象成一个图来解决。

首先将其抽象成一个有向图，然后我们会发现图中存在许多强连通分量，其实这些强连通分量可以看成同一个点，每个点中的奶牛都是互相喜欢，这也就是缩点，而如果只有一个缩完后点出度为零，则说明这个强连通分量中的所有奶牛都可以当上明星，否则就没有奶牛可以当上明星。

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 1e9 + 7;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 1e4 + 10;
int n, m, tot, cnt, ans, deg[N], scc[N], dfn[N], low[N], a[N];
bool vis[N];
std::stack<int> st;
std::vector<int> e[N], g[N];
std::vector<std::vector<int>> SCC;

void tarjan(int u) {
    low[u] = dfn[u] = ++tot;
    st.push(u);
    vis[u] = true;
    for (auto v : e[u]) if (!dfn[v]) tarjan(v), low[u] = std::min(low[u], low[v]);
    else if (vis[v]) low[u] = std::min(low[u], dfn[v]);
    if (dfn[u] == low[u]) {
        std::vector<int> v;
        while (v.empty() || v.back() != u) {
            v.pb(st.top());
            vis[st.top()] = false;
            st.pop();
        }
        SCC.pb(v);
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n >> m;
    rep(i, 1, m) {
        int u, v;
        std::cin >> u >> v;
        e[u].pb(v);
    }
    rep(i, 1, n) if (!dfn[i]) tarjan(i);
    int l = SCC.size();
    rep(i, 0, l - 1) for (auto v : SCC[i]) scc[v] = i;
    rep(u, 1, n) for (auto v : e[u]) if (scc[u] != scc[v]) deg[scc[u]]++;
    rep(i, 0, l - 1) if (!deg[i]) cnt++, ans = SCC[i].size();
    if (cnt == 1) std::cout << ans << '\n';
    else std::cout << "0\n";
}
```

感觉这种题还是需要一点图论直觉的，平时没刷过什么图论题的话根本做不出来。

**时间复杂度：** $O(n)$

## E：[燃烧](https://vjudge.net/problem/洛谷-P11378)

简单树形DP。

首先这种题肯定是有树形DP的做法的，出题人很仁慈，不用你写换根，只用记忆化一下就行了。

$dp[u]$ 表示考虑当前节点 $u$ 从 $u$ 开始最多能烧多少个节点。

$dp[u]$ 肯定是要将子节点的 $dp$ 给加上的，这一点很显然。

这是正确思路，但是我第一发写了个 $n^2$ 做法，还写错了。

我太糖了。

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 1e9 + 7;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 1e5 + 10;
int n, m, ans, dp[N], a[N];
bool vis[N];
std::vector<int> g[N];

int dfs(int u) {
    if (vis[u]) return dp[u];
    vis[u] = true;
    int cnt = 0;
    for(auto &v : g[u]) if (a[u] > a[v]) cnt += dfs(v);
    return dp[u] = cnt + 1;
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n;
    rep(i, 1, n) std::cin >> a[i];
    rep(i, 1, n - 1) {
        int u, v;
        std::cin >> u >> v;
        g[u].pb(v), g[v].pb(u);
    }
    rep(i, 1, n) ans = std::max(ans, dfs(i));
    std::cout << ans << '\n';
}
```

**时间复杂度：** $O(n)$

## D：[爆破](https://vjudge.net/problem/洛谷-P12158)

 依旧图论题。

首先这种肯定可以考虑贪心。

也许是图论题做多了，我一开始就想可以将这些圆两两之间连一条边，然后跑一边基于贪心的 `kruskal` ，但是喜提一发 `TLE`。

后面分析了以下时间复杂度，发现为 $O(m\log{m})$ 而 $m$ 是 $2.5e7$ 级别，也许是当时脑子好使，就立马想到了将边权为零的那些圆事先就用并查集连到一起，不为零的边才加入最小生成树中，就过了。

但是好像能卡。

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 1e9 + 7;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 5010;
struct node {
    int u, v;
    db w;
    bool operator < (const node &A) const {
        return w < A.w;
    }
};
struct DSU {
    std::vector<int> f, sz;
    void init(int _n) {
        f.resize(_n + 5);
        std::iota(all(f), 0);
        sz.assign(_n + 5, 1);
    }
    int find(int x) {
        while (x != f[x]) x = f[x] = f[f[x]];
        return x;
    }
    bool same(int x, int y) {return find(x) == find(y);}
    bool merge(int x, int y) {
        x = find(x), y = find(y);
        if (sz[y] > sz[x]) std::swap(x, y);
        if (x == y) return false;
        sz[x] += sz[y], f[y] = x;
        return true;
    }
    int size(int x) {return sz[find(x)];}
};
int n, cnt;
db ans, a[N][4];
std::vector<node> g;

db dist(db sx, db sy, db tx, db ty) {
    return sqrt((sx - tx) * (sx - tx) + (sy - ty) * (sy - ty));
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n;
    DSU dsu;
    dsu.init(n);
    rep(i, 1, n) rep(j, 1, 3) std::cin >> a[i][j];
    rep(i, 1, n) rep(j, i + 1, n) {
        db w = std::max(0., dist(a[i][1], a[i][2], a[j][1], a[j][2]) - a[i][3] - a[j][3]);
        if (!w) dsu.merge(i, j);
        else g.pb({i, j, w});
    }
    std::sort(all(g));
    auto kruskal = [&]() {
        for (auto &[u, v, w] : g) if (dsu.merge(u, v)) {
            ans += w;
            cnt++;
            // if (cnt == n - 1) break;
        }
    };
    kruskal();
    std::cout << std::fixed << std::setprecision(2) << ans << '\n';
}
```

**时间复杂度：** $O(m\log{m})$

又是图论，其实我感觉这种题就难在转化，其它都不是很难。



接着是全场除 I 外最难的 $C$。



## C：[Non-Descending Arrays](https://vjudge.net/problem/CodeForces-2144C)

C题看起来就像分类讨论，但是我无法证明是否正确，最后盲交一发，过了，其实写挺简单的，就是难想。

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 998244353;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 5010;
int t, n, ans, a[N], b[N];

void solve() {
    ans = 1;
    std::cin >> n;
    rep(i, 1, n) std::cin >> a[i];
    rep(i, 1, n) std::cin >> b[i];
    rep(i, 1, n - 1) if (a[i + 1] >= a[i] && b[i + 1] >= b[i] && a[i + 1] >= b[i] && b[i + 1] >= a[i]) ans *= 2, ans %= mod;
    std::cout << ans * 2 % mod << '\n';
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> t;
    while (t--) solve();
}
```

**时间复杂度：** $O(n)$

