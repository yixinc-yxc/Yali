#  10.5日雅礼总结

### 总分​ : 0 + 70 + 50 + 0 = 120;

## T1

freopen写错，0分。

假设有一个数组 $t = {2, 3, 1, 4}$

有一个$v = {5， 3， 1， 2}$

其实因为我们可以从 $k = n$ 开始，肯定全部都能选。

而如果 $k = n - 1$ 那么就只需要一不选，而其它都选，就行了。

可以发现跟 $t$ 没有关系

所以我们只需要取最大的 $k$ 个就行了。

$O(n\log{n})$

### 代码

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = 1LL << 60LL;
const int mod = 998244353;

using namespace std;

const int N = 1e5 + 10;
int n, k, t[N], v[N];
ll ans;

int main() {
    scanf("%d%d", &n, &k);
    rep(i, 1, n) scanf("%d", &t[i]);
    rep(i, 1, n) scanf("%d", &v[i]);
    sort(v + 1, v + n + 1, greater<int>());
    rep(i, 1, k) ans += v[i];
    printf("%lld\n", ans);
}
```

## T2

赛时没有看样例解释，~~眼瞎了~~

其实可以交换多位，但是我赛时只交换一位，70分。

直接爆搜，搜每一位换不换。

$O(2^6)$，好像就是 $O(1)$

### 代码

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back    
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = 1LL << 60LL;
const int mod = 998244353;

using namespace std;

const int N = 5010;
int n;
ll ans;
string s, t;

void dfs(int k, string &s, string &t) {
    if (k == n) {
        ll t1 = stoll(s), t2 = stoll(t);
        ans = max(ans, t1 * t2);
        return;
    }
    string s_ = s, t_ = t;
    swap(s_[k], t_[k]);
    dfs(k + 1, s_, t_);
    dfs(k + 1, s, t);
}

int main() {
    cin >> s >> t;
    n = s.size();
    s = " " + s, t = " " + t;
    dfs(1, s, t);
    printf("%lld\n", ans);
}
```

## T3

nm，赛时不会高精取模，导致50。

其实不需要取模，只需高精除就行了。

通过解方程，可以得知 ：

$k$ 个空瓶子 $=$ 一瓶饮料 $+$ 一个空瓶子

同时减一个空瓶子，得：

$(k - 1)$ 个空瓶子 $=$ 一瓶饮料

所以高精除就行了

### 代码

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back    
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = (1 << 30) - 1;
const ll INF = 1LL << 60LL;
const int mod = 998244353;

using namespace std;

const int N = 100010;
string s;
ll k, r, a[N], c[N];

int main() {
    cin >> s >> k;
    s = " " + s;
    int len = s.size() - 1;
    rep(i, 1, len) a[i] = s[len - i + 1] - '0';
    k--;
    frep(i, len, 1) {
        r = r * 10 + a[i];
        c[i] = r / k;
        r %= k;
    }
    while (c[len] == 0 && len > 1) len--;
    frep(i, len, 1) printf("%lld", c[i]);
    puts("");
}
```

## T4


暂时未做出。
