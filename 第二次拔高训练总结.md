# 第二次拔高训练总结

## A题：

### 思路

就是用数学方法去算，用要达成的题数去除每周所做的题数，剩下的再模拟一下就好了，但是赛时因为数字打错再加上后期没有好好检查程序，导致100挂成60分，挂了40分。

### 赛时代码：

```CPP
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--) 
#define f first
#define s second
#define all(x) (x).begin(), (x).end();
#define pb push_back
#define pf push_front
#define mp make_pair 
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 61) - 1;
const int mod = 998244353;

using namespace std;

const int N = 2010;
ll a, b, n;

int main() {
	scanf("%lld%lld%lld", &a, &b, &n);
	ll t = n / (a * 5 + 2 * b) * 7;
	ll m = n % (a * 5 + 2 * b);
	if (!m) printf("%lld\n", t), exit(0);
	int day = 1;
	while (m > 0) {
		m -= (day <= 5 ? a : b);
		day = ((day + 1) % 7 != 0 ? (day + 1) % 7 : 1);
		t++;
	}
	printf("%lld\n", t);
}
```

可以发现，我的day变量赋值错了。

### 正确代码：

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--) 
#define f first
#define s second
#define all(x) (x).begin(), (x).end();
#define pb push_back
#define pf push_front
#define mp make_pair 
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 61) - 1;
const int mod = 998244353;

using namespace std;

const int N = 2010;
ll a, b, n;

int main() {
	scanf("%lld%lld%lld", &a, &b, &n);
	ll t = n / (a * 5 + 2 * b) * 7;
	ll m = n % (a * 5 + 2 * b);
	if (!m) printf("%lld\n", t), exit(0);
	int day = 1;
	while (m > 0) {
		m -= (day <= 5 ? a : b);
		day = ((day + 1) % 7 != 0 ? (day + 1) % 7 : 7);
		t++;
	}
	printf("%lld\n", t);
}
```

**时间复杂度:**  $O(1)$

**空间复杂度:**  $O(1)$

## B题：

### 思路

赛时做出，一开始被这题的样例坑了好久，只会 $O(n^3)$ 的做法，但是这个做法无法通过此题，后面想了一下这是不是结论题，或许一条路径满足某个条件就可以选，想了一下，发现如果 $u, v$ 之间的路径长度为偶数，就一定能从中选出一个中间点 $w$ 使得 $dis(u, w) == dis(w, v)$ 我们可以举个例子：

如图：![](https://cdn.luogu.com.cn/upload/image_hosting/k8dcsqhj.png)

我们任选两点，并且它们之间距离为偶数

![](https://cdn.luogu.com.cn/upload/image_hosting/orl7plkv.png)

可见，以上结论成立。

虽然我没有严谨的证明，(~~但是好像也不需要严谨的证明~~) 但是我赛时就赌了一把，在这个结论是对的，然后就过了。

### 代码：

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--) 
#define f first
#define s second
#define all(x) (x).begin(), (x).end();
#define pb push_back
#define pf push_front
#define mp make_pair 
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 61) - 1;
const int mod = 998244353;

using namespace std;

const int N = 5010;
int n, len, ans, dis[N][N];
vector<int> g[N];
queue<int> q;
bool vis[N][N];

void bfs(int s, int dis[], bool vis[]) {
    fill(dis + 1, dis + n + 1, inf);
    fill(vis + 1, vis + n + 1, 0);
    dis[s] = 0;
    q.push(s);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        if (vis[u]) continue;
        vis[u] = true;
        for (auto v : g[u]) if (dis[u] + 1 < dis[v]) {
            dis[v] = dis[u] + 1;
            q.push(v);
        }
    }
}

int main() {
	scanf("%d", &n);
	rep(i, 1, n - 1) {
		int u, v;
		scanf("%d%d", &u, &v);
		g[u].pb(v);
		g[v].pb(u);
	}
    rep(i, 1, n) bfs(i, dis[i], vis[i]);
    rep(i, 1, n) rep(j, i + 1, n) if (!(dis[i][j] & 1)) ans = max(ans, dis[i][j]);
    printf("%d\n", ans);
}
```

**时间复杂度：**  $O(n^2)$

**空间复杂度：**  $O(n^2)$

## C题

### 思路

C题一开始没看，后面才过来看，结果时间不够，二分没写完，就结束了。

其实就是二分答案，首先我们可以发现 $L$ 这个东西是有单调性的，于是就可以二分，$check$ 的话其实就是统计一下需要加几个新的检查点就好了，注意最后的时候要判 $m + 1$ 而不是 $m$ 因为它还可以有一次加速。

### 代码

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--) 
#define f first
#define s second
#define all(x) (x).begin(), (x).end();
#define pb push_back
#define pf push_front
#define mp make_pair 
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 61) - 1;
const int mod = 998244353;

using namespace std;

const int N = 1e5 + 10;
int n, m, a[N];

bool check(int x) {
    int ans = 0;
    rep(i, 1, n) ans += (a[i] - a[i - 1] - 1) / x;
    return ans <= m + 1;
}

int main() {
    scanf("%d%d", &n, &m);
    rep(i, 1, n) scanf("%d", &a[i]);
    int l = 0, r = 1e9 + 1;
    while (l + 1 < r) {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid;
    }
    printf("%d\n", r);
}
```

**时间复杂度：**  $O(n\log(1e9))$

**空间复杂度：**  $O(n)$

## D题

赛时想了，但是写了一个 $O(n^2)$ 的做法，但是不知道为什么没对一个点。

## E题

赛时看出来是DP，但是写不出来，就没做。

## F题

又是悲惨的一题，继C题之后挂分最多的题，赛时骗分，原本能骗到60分的，但是因为没编译，导致CE了，没拿到分。

## 总结


本次总挂分 $40 + 60 + 100 = 200$ 分，多了这两百分能从第八名到第三名，下次要认真检查，写好代码后编译一下，看有没有错误，时间分配好，尽量不要出现因为没写完而失分的情况。
