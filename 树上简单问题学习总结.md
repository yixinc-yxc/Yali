# 树上简单问题学习总结

### 前置：树

树是一种特殊的图，是一个由 $n$ 个点， $n - 1$ 条边组成的无向连通图。

树还有许多的性质，这里就不再一一列举，详见 [oi-wiki](https://oi-wiki.org/graph/tree-basic/#%E5%AE%9A%E4%B9%89)。

## 一：树的直径

### 定义： 

树上两点间最长的简单路径的距离即为树的直径。

### 求法:

一般有两种求法，两遍 $dfs$ 或树形DP。

**两遍 DFS：**

先从任意一点出发，然后找到距离此点最远的点 $idx$ 再从 $idx$ 出发，找到距离 $idx$ 最远的点 ${idx}'$

则 $\delta(idx, idx')$ 就为树的直径。

而证明详见 [oi-wiki](https://oi-wiki.org/graph/tree-diameter/)

代码也是十分好写。

```cpp
auto dfs = [&](this auto &&dfs, int u, int fa) -> void {
    for (auto &v : g[u]) if (v != fa) dis[v] = dis[u] + 1, dfs(v, u);
};
dfs(1, 0);
int s = std::max_element(dis + 1, dis + n + 1) - dis;
std::fill(dis + 1, dis + n + 1, 0);
dfs(s, 0);
int t = std::max_element(dis + 1, dis + n + 1) - dis;
if (s > t) std::swap(s, t); //不一定要swap, 这里是因为swap之后更好看，具体看题面
```

此时代码中的 $\delta(s, t)$ 即为树的直径。

**树形DP：**

有负边权的情况下，不能使用DFS求法，这时就需要用到树形DP来求解。

树形DP其实也不难。

任取一个节点作为根节点，对于每个节点 $x$，考虑以 $x$ 为根节点的子树中经过 $x$ 的最长的路径，这个路径长度等于 $x$ 向下的最长路径长度 $+$ 次长路径长度，DFS时分别记录这些信息即可。

代码也非常简短。

```cpp
auto dfs = [&](this auto &&dfs, int u, int fa) -> void {
    d1[u] = d2[u] = 0;//d1为子树内最长路径, d2为子树内次长路径
    for (int v : g[u]) if (v != fa) {
        dfs(v, u);
        int dv = d1[v] + 1;//加一是因为还要加上u -> v 的这条边
        if (dv > d1[u]) std::swap(dv, d1[u]);
        if (dv > d2[u]) d2[u] = dv;
    }
    ans = std::max(ans, d1[u] + d2[u]);//最长加次长即为直径
}
```

$ans$ 即为直径的长度。

## 二：树的重心

### 定义：

如果在树 $T$ 中删去某个结点 $v$ 后，得到的图 $T$ $/$ $\{v\}$中每个连通分量的大小均不超过原树结点数的一半，就称这个结点 $v$ 为整棵树的 **重心**（centroid）。

删去某一结点后得到的最大连通分量的大小也称为该结点的 **重量**（weight)。

利用这一概念，重心的定义可以叙述为重量不超过树结点数的一半的结点。

选自oi-wiki，详见 [树的重心](https://oi-wiki.org/graph/tree-centroid/#%E5%AE%9A%E4%B9%89)。

### 性质：

● 树的重心最多只有两个，若有两个一定相邻。

● 以重心作为根节点，根节点的最大子树节点数不会超过 $\frac{n}{2}$

● 树上所有点到某个点的距离之和中，到重心的最小。

● 把两棵树用一条边连起来，形成的新的树的重心在原来两树重心之间的路径上。

● 在一颗树上添加一个叶子节点，重心最多向叶子节点移动一条边。

### 求法：

从任意一点出发，统计每一个点做根的子树大小，它到后代的子树可以递归时直接统计，而它到祖先的子树大小就是 $n - sz[i]$  其中 $sz[i]$ 表示从当前节点到后代的子树。
因为只关心最大的最小，所以只用记最大的就行了。

~~当然也能换根，没人拦你。~~

```cpp
auto dfs = [&](this auto &&dfs, int u, int fa) -> void {
    for (int v : g[u]) if (v != fa) {
        dfs(v, u);
        sz[u] += sz[v], mx[u] = std::max(mx[u], sz[v]);//统计每个节点向下的最大子树大小
    }
    sz[u]++, mx[u] = std::max(mx[u], n - sz[u]);//在和向上的子树取max, 记录最大的子树
}
int mi = *std::min_element(mx + 1, mx + n + 1);//找到最大子树最小的节点，即为重心
rep(i, 1, n) if (mx[i] == mi) std::cout << i << ' ';
```

这样就能找出所有的重心。
## 三：树的中心

### 定义：

从任意一点出发，如果这个点到所有点的距离中最长的最短，那么这个点就是这棵树的中心。

### 性质：

● 树的中心不一定唯一，最多有2个，并且如果有2个，则它们一定相邻

● 树的中心一定在树的直径上

● 树的所有点到其最远点的路径一定相交于树的中心上

● 在两颗树中间连一条边以合并成一颗树时，连接两树的中心可以让新树的直径最小

● 等权树的中心到任意一点的距离不超过 $\frac{树的直径}{2}$ 

### 求法：

树形DP。

因为只关心最长的路径，所以只用维护在其子树中的最长链、次长链，以及连向父节点的外部最长链即可。

```cpp
auto dfs = [&](this auto &&dfs, int u, int fa) -> void {//统计子树内最长和次长
    d1[u] = d2[u] = 0;//d1为子树内最长路径, d2为子树内次长路径
    for (int v : g[u]) if (v != fa) {
        dfs(v, u);
        int dv = d1[v] + 1;//加一是因为还要加上u -> v 的这条边
        if (dv > d1[u]) std::swap(dv, d1[u]);
        if (dv > d2[u]) d2[u] = dv;
    }
};

auto dfs1 = [&](this auto &&dfs1, int u, int fa) -> void {
    if (ans.empty() || std::max(d1[u], d0[u]) == std::max(d1[ans[0]], d0[ans[0]])) ans.pb(u);
    if (std::max(d1[u], d0[u]) < std::max(d1[ans[0]], d0[ans[0]])) ans.clear(), ans.pb(u);
    //ans记录了所有的重心
    for (int v : g[u]) if (v != fa) {
        if (d1[u] != d1[v] + 1) d0[v] = d1[u] + 1;
        else d0[v] = d2[u] + 1;
        d0[v] = std::max(d0[v], d0[u] + 1);
        dfs1(v, u);
    }
};
```

此时 $ans$ 中存了树上所有的中心。

~~依旧能写换根~~

## 例题

### 例题一：[树的直径](https://vjudge.net/contest/768837#problem)

**题意：**

给你一颗由 $n$ 个点，$n - 1$ 条无权边组成的树，让你求出树的直径。

**思路：**

模板题。

思路上面说了，直接上代码。

**代码：**

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 998244353;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 1e5 + 10;
int n, ans, d1[N], d2[N];
std::vector<int> g[N];

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n;
    rep(i, 1, n - 1) {
        int u, v;
        std::cin >> u >> v;
        g[u].pb(v), g[v].pb(u);
    }
    auto dfs = [&](this auto &&dfs, int u, int fa) -> void {
        d1[u] = d2[u] = 0;//d1为最长路径, d2为次长路径
        for (int v : g[u]) if (v != fa) {
            dfs(v, u);
            int dv = d1[v] + 1;//加一是因为还要加上u -> v 的这条边
            if (dv > d1[u]) std::swap(dv, d1[u]);
            if (dv > d2[u]) d2[u] = dv;
        }
        ans = std::max(ans, d1[u] + d2[u]);//最长加次长即为直径
    };
    dfs(1, 0);
    std::cout << ans << '\n';
}
```

### 例题二：[树的重心](https://vjudge.net/contest/768837#problem/B)， 原名会议

**题意：**

给你一颗由 $n$ 个点，$n - 1$ 条无权边组成的树，让你从树上选一点，使得其它所有点到这个点的距离最小。

**思路：**

由于是无权，所以可以用到上面树的重心的第三条性质。

然后找重心再算重心到每一个点的距离之和就好了。

**代码：**

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 998244353;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 1e5 + 10;
int n, idx, sz[N], mx[N];
ll ans;
std::vector<int> g[N];

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n;
    rep(i, 1, n - 1) {
        int u, v;
        std::cin >> u >> v;
        g[u].pb(v), g[v].pb(u);
    }
    auto dfs = [&](this auto &&dfs, int u, int fa) -> void {
        for (int v : g[u]) if (v != fa) {
            dfs(v, u);
            sz[u] += sz[v], mx[u] = std::max(mx[u], sz[v]);//统计每个节点向下的最大子树大小
        }
        sz[u]++, mx[u] = std::max(mx[u], n - sz[u]);//在和向上的子树取max, 记录最大的子树
    }
    auto dfs1 = [&](this auto &&dfs1, int u, int fa, int len) -> void {//统计距离
        ans += len;
        for (auto &v : g[u]) if (v != fa) dfs1(v, u, len + 1);
    };
    dfs(1, 0);
    idx = std::min_element(mx + 1, mx + n + 1) - mx;//idx就是树的重心的编号
    std::cout << idx << ' ';
    dfs1(idx, 0, 0);
    std::cout << ans << '\n';
}
```

### 例题三：[树的中心](https://vjudge.net/contest/768837#problem/C)

**题意：**

给你一颗由 $n$ 个点，$n - 1$ 条无权边组成的树，求出树所有的直径。

**思路：**

模板题，上面已经说明过了。

**代码：**

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 998244353;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 1e5 + 10;
int n, d1[N], d0[N], d2[N];
std::vector<int> ans, g[N];

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n;
    auto dfs = [&](this auto &&dfs, int u, int fa) -> void {//统计子树内最长和次长
        d1[u] = d2[u] = 0;//d1为子树内最长路径, d2为子树内次长路径
        for (int v : g[u]) if (v != fa) {
            dfs(v, u);
            int dv = d1[v] + 1;//加一是因为还要加上u -> v 的这条边
            if (dv > d1[u]) std::swap(dv, d1[u]);
            if (dv > d2[u]) d2[u] = dv;
        }
    };
    auto dfs1 = [&](this auto &&dfs1, int u, int fa) -> void {
        if (ans.empty() || std::max(d1[u], d0[u]) == std::max(d1[ans[0]], d0[ans[0]])) ans.pb(u);
        if (std::max(d1[u], d0[u]) < std::max(d1[ans[0]], d0[ans[0]])) ans.clear(), ans.pb(u);
        //ans记录了所有的重心
        for (int v : g[u]) if (v != fa) {
            if (d1[u] != d1[v] + 1) d0[v] = d1[u] + 1;
            else d0[v] = d2[u] + 1;
            d0[v] = std::max(d0[v], d0[u] + 1);
            dfs1(v, u);
        }
    };
    rep(i, 1, n - 1) {
        int u, v;
        std::cin >> u >> v;
        g[u].pb(v), g[v].pb(u);
    }
    dfs(1, 0), dfs1(1, 0);
    for (auto &v : ans) std::cout << v << ' ';
}
```

### 例题四：[Civilization](https://vjudge.net/contest/768837#problem/K)

赛时被CF2100给吓到了，另外加上因为神秘原因在外面站了十分钟，就没做出来。

其实不是很难，连我都能自己切，只要掌握一些树的性质就好了。

**题意：**

给你一个由 $n$ 个点，$m$ 条边组成的图，不一定联通，但是每一个联通块一定是一棵树。

有两种操作:

- 询问当前 $x$ 号城市所在的联通块的直径。
- 将 $x$ 所在的连通块和 $y$ 所在的连通块合并，使得新的连通块直径最小。

**思路：**

首先看到联通块和合并联通块，可以从并查集出发。

从中心的第四条性质：在两颗树中间连一条边以合并成一颗树时，连接两树的中心可以让新树的直径最小

我们可以想到合并时连接两个联通块的中心。

但是你每次连接中心，再算新的直径肯定会超时。

再想一下，连接中心之后真的还需要在统计直径吗？

在草稿纸上手推，发现新的直径只有这三种可能：

- $len[x]$
- $len[y]$
- $\left \lceil \frac{len[x]}{2} \right \rceil + \left \lceil \frac{len[y]}{{2}} \right \rceil + 1$

$len[x]$ 表示 $x$ 所在的连通块的直径。

然后就可以编代码了。

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb emplace_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 998244353;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 3e5 + 10;
int n, m, q, ans, d1[N], d2[N], len[N], a[N];
std::vector<int> g[N];
struct DSU {//并查集板子
    std::vector<int> f, sz;
    void init(int n) {
        f.resize(n + 5);
        std::iota(f.begin(), f.end(), 0);
        sz.assign(n + 5, 1);
    }
    int find(int x) {
        while (x != f[x]) x = f[x] = f[f[x]];
        return x;
    }
    bool same(int x, int y) {return find(x) == find(y);}
    bool merge(int x, int y) {//合并连通块
        x = find(x), y = find(y);
        if (sz[y] > sz[x]) std::swap(x, y);
        if (x == y) return false;
        sz[x] += sz[y];
        f[y] = x;
        len[x] = std::max({len[x], len[y], (len[x] + 1 >> 1) + (len[y] + 1 >> 1) + 1});//这句话就是上面说的求新的直径
        return true;
    }
    int size(int x) {return sz[find(x)];}
};

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n >> m >> q;
    DSU dsu;
    dsu.init(n);
    rep(i, 1, m) {
        int u, v;
        std::cin >> u >> v;
        g[u].pb(v), g[v].pb(u);
        dsu.merge(u, v);
    }
    auto dfs = [&](this auto &&dfs, int u, int fa) -> void {
        d1[u] = d2[u] = 0;//d1为子树内最长路径, d2为子树内次长路径
        for (int v : g[u]) if (v != fa) {
            dfs(v, u);
            int dv = d1[v] + 1;//加一是因为还要加上u -> v 的这条边
            if (dv > d1[u]) std::swap(dv, d1[u]);
            if (dv > d2[u]) d2[u] = dv;
        }
        ans = std::max(ans, d1[u] + d2[u]);//最长加次长即为直径
    }
    rep(i, 1, n) if (dsu.find(i) == i) dfs(i, 0), len[i] = ans, ans = 0;//len表示联通块的直径
    while (q--) {
        int op;
        std::cin >> op;
        if (op == 1) {
            int x;
            std::cin >> x;
            std::cout << len[dsu.find(x)] << '\n';//直接输出
        } else {
            int x, y;
            std::cin >> x >> y;
            dsu.merge(x, y);//合并
        }
    }
}
```