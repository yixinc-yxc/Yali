# 树上简单问题学习总结

### 前置：树

树是一种特殊的图，是一个由 $n$ 个点， $n - 1$ 条边组成的无向连通图。

树还有许多的性质，这里就不再一一列举，详见 [oi-wiki](https://oi-wiki.org/graph/tree-basic/#%E5%AE%9A%E4%B9%89)。

## 一：树的直径

### 定义： 

树上两点间最长的简单路径的距离即为树的直径。

### 求法:

一般有两种求法，两遍 $dfs$ 或树形DP。

**两遍 DFS：**

先从任意一点出发，然后找到距离此点最远的点 $idx$ 再从 $idx$ 出发，找到距离 $idx$ 最远的点 ${idx}'$

则 $\delta(idx, idx')$ 就为树的直径。

而证明详见 [oi-wiki](https://oi-wiki.org/graph/tree-diameter/)

代码也是十分好写。

```cpp
auto dfs = [&](this auto &&dfs, int u, int fa) -> void {
    for (auto &v : g[u]) if (v != fa) dis[v] = dis[u] + 1, dfs(v, u);
};
dfs(1, 0);
int s = std::max_element(dis + 1, dis + n + 1) - dis;
std::fill(dis + 1, dis + n + 1, 0);
dfs(s, 0);
int t = std::max_element(dis + 1, dis + n + 1) - dis;
if (s > t) std::swap(s, t); //不一定要swap, 这里是因为swap之后更好看，具体看题面
```

此时代码中的 $\delta(s, t)$ 即为树的直径。

**树形DP：**

有负边权的情况下，不能使用DFS求法，这时就需要用到树形DP来求解。

树形DP其实也不难。

任取一个节点作为根节点，对于每个节点 $x$，考虑以 $x$ 为根节点的子树中经过 $x$ 的最长的路径，这个路径长度等于 $x$ 向下的最长路径长度 $+$ 次长路径长度，DFS时分别记录这些信息即可。

代码也非常简短。

```cpp
auto dfs = [&](this auto &&dfs, int u, int fa) -> void {
    d1[u] = d2[u] = 0;//d1为子树内最长路径, d2为子树内次长路径
    for (int v : g[u]) if (v != fa) {
        dfs(v, u);
        int dv = d1[v] + 1;//加一是因为还要加上u -> v 的这条边
        if (dv > d1[u]) std::swap(dv, d1[u]);
        if (dv > d2[u]) d2[u] = dv;
    }
    ans = std::max(ans, d1[u] + d2[u]);//最长加次长即为直径
}
```

$ans$ 即为直径的长度。

## 二：树的重心

### 定义：

如果在树 $T$ 中删去某个结点 $v$ 后，得到的图 $T$ $/$ $\{v\}$ 中每个连通分量的大小均不超过原树结点数的一半，就称这个结点 $v$ 为整棵树的 **重心**（centroid）。

删去某一结点后得到的最大连通分量的大小也称为该结点的 **重量**（weight)。

利用这一概念，重心的定义可以叙述为重量不超过树结点数的一半的结点。

选自oi-wiki，详见 [树的重心](https://oi-wiki.org/graph/tree-centroid/#%E5%AE%9A%E4%B9%89)。

### 性质：

● 树的重心最多只有两个，若有两个一定相邻。

● 以重心作为根节点，根节点的最大子树节点数不会超过 $\frac{n}{2}$

● 树上所有点到某个点的距离之和中，到重心的最小。

● 把两棵树用一条边连起来，形成的新的树的重心在原来两树重心之间的路径上。

● 在一颗树上添加一个叶子节点，重心最多向叶子节点移动一条边。

### 求法：

从任意一点出发，统计每一个点做根的子树大小，它到后代的子树可以递归时直接统计，而它到祖先的子树大小就是 $n - sz[i]$  其中 $sz[i]$ 表示从当前节点到后代的子树。
因为只关心最大的最小，所以只用记最大的就行了。

~~当然也能换根，没人拦你。~~

```cpp
auto dfs = [&](this auto &&dfs, int u, int fa) -> void {
    for (int v : g[u]) if (v != fa) {
        dfs(v, u);
        sz[u] += sz[v], mx[u] = std::max(mx[u], sz[v]);//统计每个节点向下的最大子树大小
    }
    sz[u]++, mx[u] = std::max(mx[u], n - sz[u]);//在和向上的子树取max, 记录最大的子树
}
int mi = *std::min_element(mx + 1, mx + n + 1);//找到最大子树最小的节点，即为重心
rep(i, 1, n) if (mx[i] == mi) std::cout << i << ' ';
```

这样就能找出所有的重心。
## 三：树的中心

### 定义：

从任意一点出发，如果这个点到所有点的距离中最长的最短，那么这个点就是这棵树的中心。

### 性质：

● 树的中心不一定唯一，最多有2个，并且如果有2个，则它们一定相邻

● 树的中心一定在树的直径上

● 树的所有点到其最远点的路径一定相交于树的中心上

● 在两颗树中间连一条边以合并成一颗树时，连接两树的中心可以让新树的直径最小

● 等权树的中心到任意一点的距离不超过 $\frac{树的直径}{2}$ 

### 求法：

树形DP。

因为只关心最长的路径，所以只用维护在其子树中的最长链、次长链，以及连向父节点的外部最长链即可。

```cpp
auto dfs = [&](this auto &&dfs, int u, int fa) -> void {//统计子树内最长和次长
    d1[u] = d2[u] = 0;//d1为子树内最长路径, d2为子树内次长路径
    for (int v : g[u]) if (v != fa) {
        dfs(v, u);
        int dv = d1[v] + 1;//加一是因为还要加上u -> v 的这条边
        if (dv > d1[u]) std::swap(dv, d1[u]);
        if (dv > d2[u]) d2[u] = dv;
    }
};

auto dfs1 = [&](this auto &&dfs1, int u, int fa) -> void {
    if (ans.empty() || std::max(d1[u], d0[u]) == std::max(d1[ans[0]], d0[ans[0]])) ans.pb(u);
    if (std::max(d1[u], d0[u]) < std::max(d1[ans[0]], d0[ans[0]])) ans.clear(), ans.pb(u);
    //ans记录了所有的重心
    for (int v : g[u]) if (v != fa) {
        if (d1[u] != d1[v] + 1) d0[v] = d1[u] + 1;
        else d0[v] = d2[u] + 1;
        d0[v] = std::max(d0[v], d0[u] + 1);
        dfs1(v, u);
    }
};
```

此时 $ans$ 中存了树上所有的中心。

~~依旧能写换根~~

## 例题

### 例题一：[树的直径](https://vjudge.net/contest/768837#problem)

**题意：**

给你一颗由 $n$ 个点， $n - 1$ 条无权边组成的树，让你求出树的直径。

**思路：**

模板题。

思路上面说了，直接上代码。

**代码：**

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 998244353;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 1e5 + 10;
int n, ans, d1[N], d2[N];
std::vector<int> g[N];

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n;
    rep(i, 1, n - 1) {
        int u, v;
        std::cin >> u >> v;
        g[u].pb(v), g[v].pb(u);
    }
    auto dfs = [&](this auto &&dfs, int u, int fa) -> void {
        d1[u] = d2[u] = 0;//d1为最长路径, d2为次长路径
        for (int v : g[u]) if (v != fa) {
            dfs(v, u);
            int dv = d1[v] + 1;//加一是因为还要加上u -> v 的这条边
            if (dv > d1[u]) std::swap(dv, d1[u]);
            if (dv > d2[u]) d2[u] = dv;
        }
        ans = std::max(ans, d1[u] + d2[u]);//最长加次长即为直径
    };
    dfs(1, 0);
    std::cout << ans << '\n';
}
```

### 例题二：[树的重心](https://vjudge.net/contest/768837#problem/B)， 原名会议

**题意：**

给你一颗由 $n$ 个点， $n - 1$ 条无权边组成的树，让你从树上选一点，使得其它所有点到这个点的距离最小。

**思路：**

由于是无权，所以可以用到上面树的重心的第三条性质。

然后找重心再算重心到每一个点的距离之和就好了。

**代码：**

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 998244353;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 1e5 + 10;
int n, idx, sz[N], mx[N];
ll ans;
std::vector<int> g[N];

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n;
    rep(i, 1, n - 1) {
        int u, v;
        std::cin >> u >> v;
        g[u].pb(v), g[v].pb(u);
    }
    auto dfs = [&](this auto &&dfs, int u, int fa) -> void {
        for (int v : g[u]) if (v != fa) {
            dfs(v, u);
            sz[u] += sz[v], mx[u] = std::max(mx[u], sz[v]);//统计每个节点向下的最大子树大小
        }
        sz[u]++, mx[u] = std::max(mx[u], n - sz[u]);//在和向上的子树取max, 记录最大的子树
    }
    auto dfs1 = [&](this auto &&dfs1, int u, int fa, int len) -> void {//统计距离
        ans += len;
        for (auto &v : g[u]) if (v != fa) dfs1(v, u, len + 1);
    };
    dfs(1, 0);
    idx = std::min_element(mx + 1, mx + n + 1) - mx;//idx就是树的重心的编号
    std::cout << idx << ' ';
    dfs1(idx, 0, 0);
    std::cout << ans << '\n';
}
```

### 例题三：[树的中心](https://vjudge.net/contest/768837#problem/C)

**题意：**

给你一颗由 $n$ 个点， $n - 1$ 条无权边组成的树，求出树所有的直径。

**思路：**

模板题，上面已经说明过了。

**代码：**

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 998244353;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 1e5 + 10;
int n, d1[N], d0[N], d2[N];
std::vector<int> ans, g[N];

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n;
    auto dfs = [&](this auto &&dfs, int u, int fa) -> void {//统计子树内最长和次长
        d1[u] = d2[u] = 0;//d1为子树内最长路径, d2为子树内次长路径
        for (int v : g[u]) if (v != fa) {
            dfs(v, u);
            int dv = d1[v] + 1;//加一是因为还要加上u -> v 的这条边
            if (dv > d1[u]) std::swap(dv, d1[u]);
            if (dv > d2[u]) d2[u] = dv;
        }
    };
    auto dfs1 = [&](this auto &&dfs1, int u, int fa) -> void {
        if (ans.empty() || std::max(d1[u], d0[u]) == std::max(d1[ans[0]], d0[ans[0]])) ans.pb(u);
        if (std::max(d1[u], d0[u]) < std::max(d1[ans[0]], d0[ans[0]])) ans.clear(), ans.pb(u);
        //ans记录了所有的重心
        for (int v : g[u]) if (v != fa) {
            if (d1[u] != d1[v] + 1) d0[v] = d1[u] + 1;
            else d0[v] = d2[u] + 1;
            d0[v] = std::max(d0[v], d0[u] + 1);
            dfs1(v, u);
        }
    };
    rep(i, 1, n - 1) {
        int u, v;
        std::cin >> u >> v;
        g[u].pb(v), g[v].pb(u);
    }
    dfs(1, 0), dfs1(1, 0);
    for (auto &v : ans) std::cout << v << ' ';
}
```

### 例题四：[Civilization](https://vjudge.net/contest/768837#problem/K)

赛时被CF2100给吓到了，另外加上因为神秘原因在外面站了十分钟，就没做出来。

其实不是很难，连我都能自己切，只要掌握一些树的性质就好了。

**题意：**

给你一个由 $n$ 个点， $m$ 条边组成的图，不一定联通，但是每一个联通块一定是一棵树。

有两种操作:

- 询问当前 $x$ 号城市所在的联通块的直径。
- 将 $x$ 所在的连通块和 $y$ 所在的连通块合并，使得新的连通块直径最小。

**思路：**

首先看到联通块和合并联通块，可以从并查集出发。

从中心的第四条性质：在两颗树中间连一条边以合并成一颗树时，连接两树的中心可以让新树的直径最小

我们可以想到合并时连接两个联通块的中心。

但是你每次连接中心，再算新的直径肯定会超时。

再想一下，连接中心之后真的还需要在统计直径吗？

在草稿纸上手推，发现新的直径只有这三种可能：

- $len[x]$
- $len[y]$
- $\left \lceil \frac{len[x]}{2} \right \rceil + \left \lceil \frac{len[y]}{{2}} \right \rceil + 1$

$len[x]$ 表示 $x$ 所在的连通块的直径。

然后就可以编代码了。

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb emplace_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 1e9;
const ll INF = 1LL << 60LL;
const int mod = 998244353;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 3e5 + 10;
int n, m, q, ans, d1[N], d2[N], len[N], a[N];
std::vector<int> g[N];
struct DSU {//并查集板子
    std::vector<int> f, sz;
    void init(int n) {
        f.resize(n + 5);
        std::iota(f.begin(), f.end(), 0);
        sz.assign(n + 5, 1);
    }
    int find(int x) {
        while (x != f[x]) x = f[x] = f[f[x]];
        return x;
    }
    bool same(int x, int y) {return find(x) == find(y);}
    bool merge(int x, int y) {//合并连通块
        x = find(x), y = find(y);
        if (sz[y] > sz[x]) std::swap(x, y);
        if (x == y) return false;
        sz[x] += sz[y];
        f[y] = x;
        len[x] = std::max({len[x], len[y], (len[x] + 1 >> 1) + (len[y] + 1 >> 1) + 1});//这句话就是上面说的求新的直径
        return true;
    }
    int size(int x) {return sz[find(x)];}
};

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n >> m >> q;
    DSU dsu;
    dsu.init(n);
    rep(i, 1, m) {
        int u, v;
        std::cin >> u >> v;
        g[u].pb(v), g[v].pb(u);
        dsu.merge(u, v);
    }
    auto dfs = [&](this auto &&dfs, int u, int fa) -> void {
        d1[u] = d2[u] = 0;//d1为子树内最长路径, d2为子树内次长路径
        for (int v : g[u]) if (v != fa) {
            dfs(v, u);
            int dv = d1[v] + 1;//加一是因为还要加上u -> v 的这条边
            if (dv > d1[u]) std::swap(dv, d1[u]);
            if (dv > d2[u]) d2[u] = dv;
        }
        ans = std::max(ans, d1[u] + d2[u]);//最长加次长即为直径
    }
    rep(i, 1, n) if (dsu.find(i) == i) dfs(i, 0), len[i] = ans, ans = 0;//len表示联通块的直径
    while (q--) {
        int op;
        std::cin >> op;
        if (op == 1) {
            int x;
            std::cin >> x;
            std::cout << len[dsu.find(x)] << '\n';//直接输出
        } else {
            int x, y;
            std::cin >> x >> y;
            dsu.merge(x, y);//合并
        }
    }
}
```





---------



## 四 : 树上LCA

### 定义：

在有根树上，对于两个点 $u$ $v$，这两个点的所有公共祖先中，距离根节点最远的节点，就是 $u$ 和 $v$ 的最近公共祖先（LCA）

对于一个点集，这些点的所有公共祖先中，距离根节点最远的节点，就是这些点的 LCA。

### 求法：

从暴力开始。

首先最暴力的做法肯定是先把两个跳到同一个深度，然后再继续往上跳，直到两个节点相等，此节点即为LCA。

暴力代码就不放了，相信都会写。

时间复杂度： $O(n)$

**倍增:**

其实这种方法就是暴力的优化。

首先一层一层的跳太慢了，可以考虑一次多跳几层，

于是，我们想到可以倍增优化。

先把两个跳到同一个深度。

如果两点此时已经相同了的话就直接输出。

否则每次还要枚举跳 $2$ 的几次方层，然后往上跳，知道跳到LCA的子节点。

最后输出当前节点的父节点，就是LCA。

预处理 $O(n\log{n})$

单次查询 $O(\log{n})$

**代码**

```cpp
int f[21][N], dep[N];
std::vector<int> g[N];

void dfs(int u, int fa) {
    for (auto &v : g[u]) if (v != fa) {
        f[0][v] = u;
        dep[v] = dep[u] + 1;
        dfs(v, u);
    }
}

int lca(int u, int v) {
    if (dep[u] < dep[v]) std::swap(u, v);
    int d = dep[u] - dep[v];
    for (int j = 0; d; j++, d >>= 1) if (d & 1) u = f[j][u];
    if (u == v) return u;
    frep(j, 20, 0) if (f[j][u] != f[j][v]) u = f[j][u], v = f[j][v];
    return f[0][u];
}
```

**dfn上ST表求LCA**

这种做法理论上是 $O(1)$ 的，但是其实常数很大，和 $\log$ 实测没什么太大的区别。

首先处理出 `dfn`  ，然后在 `dfn` 上建 `st` 表维护区间内距离根节点最近的节点。

查询 `lca` 时，设最小 `dfn` 为 `l` ，最大 `dfn` 为 `r`，

只需要查询 $[l + 1, r]$ 区间内距离根节点最近的节点，该节点的父节点即为 `lca` 

但是我不会。

### 注意：倍增以及ST表小的一维一定要开前面，不是常数的问题，是有可能TLE！！！

## 例题：

### 例题一：[模板LCA](https://vjudge.net/contest/776080#problem/A)

#### 思路：

模板题，我用的 $O(\log{n})$ 求法。 

#### 代码

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb emplace_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 2e9;
const ll INF = 1LL << 60LL;
const int mod = 998244353;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 5e5 + 10;
int n, m, s, dis[N], fa[21][N];
std::vector<int> g[N];

void dfs(int u, int f) {for (auto v : g[u]) if (v != f) dis[v] = dis[u] + 1, fa[0][v] = u, dfs(v, u);}

void lca(int u, int v) {
    if (dis[u] < dis[v]) std::swap(u, v);
    int d = dis[u] - dis[v];
    for (int j = 0; d; j++, d >>= 1) if (d & 1) u = fa[j][u];
    if (u == v) return std::cout << u << '\n', void();
    frep(j, 20, 0) if (fa[j][u] != fa[j][v]) u = fa[j][u], v = fa[j][v];
    std::cout << fa[0][u] << '\n';
}


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n >> m >> s;
    rep(i, 1, n - 1) {
        int u, v;
        std::cin >> u >> v;
        g[u].pb(v), g[v].pb(u);
    }
    dfs(s, 0);
    rep(j, 1, 20) rep(i, 1, n) fa[j][i] = fa[j - 1][fa[j - 1][i]];
    while (m--) {
        int u, v;
        std::cin >> u >> v;
        lca(u, v);
    } 
}
```

### 例题二：[大量的工作沟通](https://vjudge.net/contest/776080#problem/B)

#### 思路：

首先题意看来是求公共祖先，于是可以想到先将整个点集的最近公共最先求出来，然后直接输出，但是会被HACK掉

再次观察题目，如果有多个节点的话是输出最大的那一个，且不一定小的管大的，所以我们不仅要求出最近公共祖先，而且还要求出最近公共祖先的祖先中编号最大的。

于是就过了。

#### 代码：

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb emplace_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 2e9;
const ll INF = 1LL << 60LL;
const int mod = 998244353;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 4e5 + 10;
int n, q, dis[N], mx[N], fa[21][N];
std::vector<int> g[N];

void dfs(int u, int f) {for (auto &v : g[u]) if (v != f) dis[v] = dis[u] + 1, mx[u] = std::max(mx[f], u), fa[0][v] = u, dfs(v, u);}

int lca(int u, int v) {
    if (dis[u] < dis[v]) std::swap(u, v);
    int d = dis[u] - dis[v];
    for (int j = 0; d; j++, d >>= 1) if (d & 1) u = fa[j][u];
    if (u == v) return u;
    frep(j, 20, 0) if (fa[j][u] != fa[j][v]) u = fa[j][u], v = fa[j][v];
    return fa[0][u];
}


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n;
    rep(i, 2, n) {
        int f;
        std::cin >> f;
        f++;
        g[f].pb(i), g[i].pb(f);
    }
    std::cin >> q;
    dfs(1, 0);
    rep(j, 1, 20) rep(i, 1, n) fa[j][i] = fa[j - 1][fa[j - 1][i]];
    while (q--) {
        int m;
        std::cin >> m;
        std::vector<int> a;
        a.clear();
        rep(i, 1, m) {
            int x;
            std::cin >> x;
            a.pb(x + 1);
        }
        sort(all(a));
        int ans = a[0];
        rep(i, 1, m - 1) ans = lca(ans, a[i]);
        // frep(i, 20, 0) ans = std::max(ans, fa[i][ans]);
        std::cout << mx[ans] - 1 << '\n';
    }
}
```

### 例题三：[The Shortest Statement](https://vjudge.net/contest/776080#problem/I)

CF2400, 曾被评过黑，现在是蓝。

写的最认真的一题。

#### 思路：

其实不是老师讲后很难，首先如果这题换成是一棵树，而不是一个图，相信大家都会做。

想要树上 $(u, v)$ 之间的距离，先找到最近公共祖先，再用 $dis(1, u) + dis(1, v) - dis(1, lca(u, v))$ 结果即为两点距离。

观察到题面特意标出了 $m - n <= 20$ 说明最多只有可能会多出 $21$ 条边。

所以可以想到先把这些边都给抠出来，然后原图就成了一棵树，树上距离刚刚也说了，而抠出来的图只需要用 `dijkstra` 求一边就行了。

而如何将边全部抠出来呢？可以使用并查集，来判断两个点的连通性，从而判断这条边是不是多余的，如果是，就将这两点设为d `dijkstra` 的起点，否则就将这两个点在树上连接。

#### 代码：

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair
#define s second
#define f first
const int inf = 2e9;
const ll INF = 1LL << 60LL;
const int mod = 998244353;
const db eps = 1e-9;
std::mt19937_64 rng(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 1e5 + 10;
struct node {
    int v;
    ll w;
};
int n, m, Q, ans, dep[N], fa[21][N];
ll dist[N];
std::vector<node> g[N], tree[N];
std::vector<int> s;
std::priority_queue<std::pair<ll, int>> q;
struct DSU {
    std::vector<int> f, sz;
    void init(int _n) {
        f.resize(_n + 5);
        std::iota(all(f), 0);
        sz.assign(_n + 5, 1);
    }
    int find(int x) {
        while (x != f[x]) x = f[x] = f[f[x]];
        return x;
    }
    bool same(int x, int y) {return find(x) == find(y);}
    bool merge(int x, int y) {
        x = find(x), y = find(y);
        if (sz[y] > sz[x]) std::swap(x, y);
        if (x == y) return false;
        sz[x] += sz[y], f[y] = x;
        return true;
    }
    int size(int x) {return sz[find(x)];}
};

void dfs(int u, int f) {
    for (auto &y : tree[u]) if (y.v != f) {
        int v = y.v;
        ll w = y.w;
        fa[0][v] = u;
        dist[v] = dist[u] + w;
        dep[v] = dep[u] + 1;
        dfs(v, u);
    }
}

int lca(int u, int v) {
    if (dep[u] < dep[v]) std::swap(u, v);
    int d = dep[u] - dep[v];
    for (int j = 0; d; j++, d >>= 1) if (d & 1) u = fa[j][u];
    if (u == v) return u;
    frep(j, 20, 0) if (fa[j][u] != fa[j][v]) u = fa[j][u], v = fa[j][v];
    return fa[0][u];
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::cin >> n >> m;
    DSU dsu;
    dsu.init(n);
    rep(i, 1, m) {
        int u, v, w;
        std::cin >> u >> v >> w;
        g[u].pb({v, w}), g[v].pb({u, w});
        if (!dsu.merge(u, v)) s.pb(u), s.pb(v);
        else tree[u].pb({v, w}), tree[v].pb({u, w});
    }
    dfs(1, 0);
    std::map<int, std::vector<ll>> DIS;
    std::vector<bool> vis(n + 5, false);
    auto dijkstra = [&](int u) {//dijkstra板子
        auto &dis = DIS[u];
        dis.resize(n + 5);
        std::fill(all(vis), false);
        std::fill(all(dis), INF);
        q.push({0ll, u});
        dis[u] = 0;
        while (!q.empty()) {
            ll d = -q.top().f;
            int u = q.top().s;
            q.pop();
            if (vis[u]) continue;
            vis[u] = true;
            for (auto &y : g[u]) {
                int v = y.v;
                ll w = y.w;
                if (dis[u] + w < dis[v]) {
                    dis[v] = dis[u] + w;
                    q.push({-dis[v], v});
                }
            }
        }
    };
    rep(j, 1, 20) rep(i, 1, n) fa[j][i] = fa[j - 1][fa[j - 1][i]];
    for (auto &v : s) dijkstra(v);
    std::cin >> Q;
    while (Q--) {
        int x, y;
        std::cin >> x >> y;
        ll ans = dist[x] + dist[y] - 2 * dist[lca(x, y)];
        for (auto u : s) ans = std::min(ans, DIS[u][x] + DIS[u][y]);
        std::cout << ans << '\n';
    }
}
```

121行~~屎山~~代码。

**编码时猎奇错误分享**


首先当时很急，写的时候根本不带脑子，`dijkstra` 模板写出了3个错误，调半天才调出来，后面是因为DIS的长度开成 `s.size()` 了，又调了很久，后面完全不当人了，一直提交，一直MLE，后面去听讲座，然后讲座回来发现竟然是因为开了 $n^2$ 的 `vector` ($n \leq 10^5$)，于是就 `AC` 了。
