# 高斯消元学习总结

** 前记: ** 今天竟然是猫猫头讲课，好久没看见猫猫头了

## 概念

顾名思义，高斯消元就是一种用来消元的算法(但是时间复杂度很高，猜测后面还会有优化版)，其实就是一步步去模拟你消元的过程就好了，但是要注意消元的顺序，因为有时消元的顺序会影响正确性。

## 题目

### 高斯消元

[题目](https://vjudge.net/contest/747431#problem/A)

就是高斯消元模板，做这个题前先通过一些神秘手法写了几个代码结果最后的矩阵还求对了，但是后面老师教了我们真正的高斯消元，于是我就做掉了这道题。

#### 代码

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
// using pii = pair<int, int>;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--) 
#define f first
#define s second
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair 
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 61) - 1;
const int mod = 998244353;

using namespace std;

const db eps = 1e-7;
const int N = 110;
int n;
db a[N][N];

int main() {
    scanf("%d", &n);
    rep(i, 1, n) rep(j, 1, n + 1) scanf("%lf", &a[i][j]);//输入矩阵
    rep(k, 1, n) {//现在要消xk, 但是第k行的xk要保留
        int mx = k;
        rep(i, k + 1, n) mx = (fabs(a[i][k]) - fabs(a[mx][k]) > eps ? i : mx);//寻找最大的系数, 具体原因就是防止精度误差
        rep(i, 1, n + 1) swap(a[k][i], a[mx][i]);//交换
        if (fabs(a[k][k]) < eps) return puts("No Solution"), 0;//判无解
        frep(i, n + 1, 1) a[k][i] /= a[k][k];
        rep(i, 1, n) if (i != k) {//从1枚举到n的原因是因为后面好求答案
            db t = (a[i][k] / a[k][k]);
            rep(j, 1, n + 1) a[i][j] -= a[k][j] * t;//消元
        }
    }
    rep(i, 1, n) printf("%.2f\n", a[i][n + 1]);
    /**
    因为上面是从1到n, 所以最终的方程一定长这个样子:
	x1 = c1;
	x2 = c2;
	x3 = c3;
	...
	否则就是无解
    **/
}
```



**时间复杂度：** $ O(n^3) $

**空间复杂度：** $ O(n^2) $

### 线性方程组 

[题目](https://vjudge.net/contest/747431#problem/F)

其实和上面的方法差不多，就是要多判几个无解和无穷解，其实无解就是系数项为0，但是常数项大于0，就是无解，但是一定要注意要先判无解，再判无穷解，无穷解就是系数项为0，且常数项也为0，就可以了，但是要注意这道题需要修改消元的顺序，不然就会错。

#### 代码

```cpp
#include <bits/stdc++.h>

using ll = long long;
using ull = unsigned long long;
using i128 = __int128;
using db = double;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define frep(i, b, a) for (int i = b; i >= a; i--) 
#define f first
#define s second
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define pf push_front
#define mp make_pair 
const int inf = (1 << 30) - 1;
const ll INF = (1LL << 61) - 1;
const int mod = 998244353;

using namespace std;

const db eps = 1e-7;
const int N = 110;
int n;
db a[N][N];

int main() {
    scanf("%d", &n);
    rep(i, 1, n) rep(j, 1, n + 1) scanf("%lf", &a[i][j]);
    rep(k, 1, n) {
        int mx = k;
        rep(i, 1, n) {//消元顺序修改
            if (fabs(a[i][i]) > eps && i < k) continue;
            mx = (fabs(a[i][k]) - fabs(a[mx][k]) > eps ? i : mx);
        }
        rep(i, 1, n + 1) swap(a[k][i], a[mx][i]);
        if (fabs(a[k][k]) < eps) continue;
        frep(i, n + 1, 1) a[k][i] /= a[k][k];
        rep(i, 1, n) if (i != k) {
            db t = (a[i][k] / a[k][k]);
            rep(j, 1, n + 1) a[i][j] -= a[k][j] * t;
        }
    }
    rep(i, 1, n) if (fabs(a[i][i]) < eps && fabs(a[i][n + 1]) > eps) return puts("-1"), 0;
    rep(i, 1, n) if (fabs(a[i][i]) < eps) return puts("0"), 0;
    rep(i, 1, n) printf("x%d=%.5f\n", i, a[i][n + 1]);
    return 0;
}

```
